<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Chess Tic-Tac-Toe Online</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #654321 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            background: #2c1810;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            border: 3px solid #8B4513;
        }

        @media (min-width: 768px) {
            .game-container {
                padding: 40px;
            }
        }

        .title {
            text-align: center;
            color: #f0d9b5;
            margin-bottom: 5px;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        @media (min-width: 768px) {
            .title {
                font-size: 32px;
                margin-bottom: 10px;
            }
        }

        .subtitle {
            text-align: center;
            color: #b58863;
            margin-bottom: 20px;
            font-size: 12px;
        }

        @media (min-width: 768px) {
            .subtitle {
                font-size: 14px;
                margin-bottom: 30px;
            }
        }

        .game-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            color: #f0d9b5;
            min-height: 28px;
        }

        .player-indicator {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
        }

        .white-turn {
            background: #f0d9b5;
            color: #2c1810;
            border: 2px solid #b58863;
        }

        .black-turn {
            background: #2c1810;
            color: #f0d9b5;
            border: 2px solid #b58863;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0;
            margin: 20px auto;
            max-width: 400px;
            aspect-ratio: 1;
            touch-action: manipulation;
            border: 4px solid #8B4513;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        @media (min-width: 768px) {
            .board {
                margin: 30px auto;
            }
        }

        .square {
            aspect-ratio: 1;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 60px;
        }

        /* Row 1: light, dark, light, dark */
        .square:nth-child(1) { background: #f0d9b5; }
        .square:nth-child(2) { background: #b58863; }
        .square:nth-child(3) { background: #f0d9b5; }
        .square:nth-child(4) { background: #b58863; }
        
        /* Row 2: dark, light, dark, light */
        .square:nth-child(5) { background: #b58863; }
        .square:nth-child(6) { background: #f0d9b5; }
        .square:nth-child(7) { background: #b58863; }
        .square:nth-child(8) { background: #f0d9b5; }
        
        /* Row 3: light, dark, light, dark */
        .square:nth-child(9) { background: #f0d9b5; }
        .square:nth-child(10) { background: #b58863; }
        .square:nth-child(11) { background: #f0d9b5; }
        .square:nth-child(12) { background: #b58863; }
        
        /* Row 4: dark, light, dark, light */
        .square:nth-child(13) { background: #b58863; }
        .square:nth-child(14) { background: #f0d9b5; }
        .square:nth-child(15) { background: #b58863; }
        .square:nth-child(16) { background: #f0d9b5; }

        @media (min-width: 768px) {
            .square {
                font-size: 48px;
            }
        }

        .square:active {
            filter: brightness(0.9);
            transform: scale(0.95);
        }

        @media (hover: hover) {
            .square:hover {
                filter: brightness(1.1);
            }
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px #ffd700;
            filter: brightness(1.2);
        }

        .square.valid-move {
            box-shadow: inset 0 0 0 4px #90EE90;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #90EE90;
            border-radius: 50%;
            opacity: 0.6;
        }

        .piece {
            user-select: none;
            position: relative;
        }

        .pawn-direction {
            position: absolute;
            font-size: 14px;
            top: -6px;
            right: -6px;
        }

        @media (min-width: 768px) {
            .pawn-direction {
                font-size: 16px;
                top: -8px;
                right: -8px;
            }
        }

        .hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: #3d2817;
            border-radius: 8px;
            flex-wrap: wrap;
            border: 2px solid #8B4513;
        }

        @media (min-width: 768px) {
            .hand {
                gap: 15px;
                margin: 20px 0;
                padding: 15px;
            }
        }

        .hand-piece {
            padding: 10px 16px;
            border: 2px solid #8B4513;
            border-radius: 8px;
            cursor: pointer;
            font-size: 28px;
            background: #f0d9b5;
            transition: all 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-width: 56px;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        @media (min-width: 768px) {
            .hand-piece {
                padding: 12px 20px;
                font-size: 32px;
            }
        }

        .hand-piece:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        @media (hover: hover) {
            .hand-piece:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                background: #fff;
            }
        }

        .hand-piece.selected {
            background: #ffd700;
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        .hand-piece.captured {
            opacity: 0.3;
            background: #b58863;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 48px;
            border: 2px solid #8B4513;
        }

        .primary-btn {
            background: #8B4513;
            color: #f0d9b5;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .primary-btn:active {
            background: #654321;
            transform: scale(0.98);
        }

        .primary-btn:disabled {
            background: #6b5746;
            opacity: 0.5;
            cursor: not-allowed;
        }

        @media (hover: hover) {
            .primary-btn:hover:not(:disabled) {
                background: #A0522D;
                transform: translateY(-1px);
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
            }
        }

        .secondary-btn {
            background: #b58863;
            color: #2c1810;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .secondary-btn:active {
            background: #a07855;
            transform: scale(0.98);
        }

        @media (hover: hover) {
            .secondary-btn:hover {
                background: #c99a73;
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
            }
        }

        .winner-message {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 12px;
            margin: 20px 0;
            font-size: 24px;
            font-weight: 700;
            color: #2c1810;
            animation: celebration 0.5s ease-in-out;
            border: 3px solid #FFD700;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.5);
        }

        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .setup-screen {
            text-align: center;
        }

        .setup-screen input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #8B4513;
            border-radius: 8px;
            font-size: 16px;
            background: #f0d9b5;
            color: #2c1810;
        }

        .setup-screen input::placeholder {
            color: #8B4513;
        }

        .game-id-display {
            background: #3d2817;
            padding: 12px;
            border-radius: 8px;
            margin: 12px 0;
            font-family: monospace;
            font-size: 16px;
            word-break: break-all;
            color: #f0d9b5;
            border: 2px solid #8B4513;
        }

        @media (min-width: 768px) {
            .game-id-display {
                padding: 15px;
                margin: 15px 0;
                font-size: 18px;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #f0d9b5;
        }

        .player-hands {
            margin: 20px 0;
        }

        .hand-label {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            color: #f0d9b5;
        }

        .turn-info {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            background: #3d2817;
            border-radius: 8px;
            font-size: 14px;
            color: #b58863;
            border: 1px solid #8B4513;
        }

        .waiting-message {
            text-align: center;
            padding: 15px;
            background: #8B4513;
            border-radius: 8px;
            margin: 15px 0;
            color: #f0d9b5;
            border: 2px solid #b58863;
        }

        .connection-status {
            text-align: center;
            padding: 8px;
            background: #3d2817;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
            color: #90EE90;
            border: 1px solid #8B4513;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Piece unicode characters
        const PIECES = {
            white: {
                pawn: '‚ôô',
                rook: '‚ôñ',
                knight: '‚ôò',
                bishop: '‚ôó'
            },
            black: {
                pawn: '‚ôü',
                rook: '‚ôú',
                knight: '‚ôû',
                bishop: '‚ôù'
            }
        };

        function App() {
            const [gameState, setGameState] = useState(null);
            const [gameId, setGameId] = useState('');
            const [playerColor, setPlayerColor] = useState(null);
            const [setupMode, setSetupMode] = useState('choose');
            const [inputGameId, setInputGameId] = useState('');
            const [selectedSquare, setSelectedSquare] = useState(null);
            const [selectedHandPiece, setSelectedHandPiece] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [connected, setConnected] = useState(false);
            const [copied, setCopied] = useState(false);
            const [soundEnabled, setSoundEnabled] = useState(true);
            const [joining, setJoining] = useState(false);
            const [joinAttempt, setJoinAttempt] = useState(0);
            const gunRef = useRef(null);
            const gameRef = useRef(null);

            const playSound = (type) => {
                if (!soundEnabled) return;
                const audio = new Audio();
                if (type === 'move') {
                    // Simple move sound
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.1);
                } else if (type === 'win') {
                    // Win sound
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    [300, 400, 500].forEach((freq, i) => {
                        const oscillator = ctx.createOscillator();
                        const gainNode = ctx.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(ctx.destination);
                        oscillator.frequency.value = freq;
                        gainNode.gain.setValueAtTime(0.1, ctx.currentTime + i * 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.1 + 0.2);
                        oscillator.start(ctx.currentTime + i * 0.1);
                        oscillator.stop(ctx.currentTime + i * 0.1 + 0.2);
                    });
                }
            };

            const copyGameId = () => {
                navigator.clipboard.writeText(gameId).then(() => {
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                }).catch(() => {
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = gameId;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                });
            };

            useEffect(() => {
                // Initialize Gun with multiple relay servers for better reliability
                gunRef.current = Gun([
                    'https://gun-manhattan.herokuapp.com/gun',
                    'https://gunjs.herokuapp.com/gun',
                    'https://e2eec.herokuapp.com/gun'
                ]);
                setConnected(true);

                // Restore session from localStorage after a short delay
                setTimeout(() => {
                    const savedGameId = localStorage.getItem('chessGameId');
                    const savedPlayerColor = localStorage.getItem('chessPlayerColor');
                    
                    if (savedGameId && savedPlayerColor) {
                        setGameId(savedGameId);
                        setPlayerColor(savedPlayerColor);
                        setSetupMode('playing');
                    }
                }, 500);
            }, []);

            useEffect(() => {
                if (!gameId || !gunRef.current) return;

                // Subscribe to game updates
                gameRef.current = gunRef.current.get('chess-tictactoe').get(gameId);
                
                let timeout = setTimeout(() => {
                    // If no data received after 3 seconds, check if game exists
                    if (!gameState) {
                        gameRef.current.once((data) => {
                            if (!data || !data.state) {
                                console.log('Game not found, clearing session');
                                localStorage.removeItem('chessGameId');
                                localStorage.removeItem('chessPlayerColor');
                                setGameId('');
                                setPlayerColor(null);
                                setSetupMode('choose');
                                alert('Could not reconnect to game. It may have expired.');
                            }
                        });
                    }
                }, 3000);
                
                gameRef.current.on((data) => {
                    if (data && data.state) {
                        try {
                            const state = JSON.parse(data.state);
                            setGameState(state);
                            clearTimeout(timeout);
                        } catch (e) {
                            console.error('Error parsing game state:', e);
                        }
                    }
                });

                return () => {
                    clearTimeout(timeout);
                    if (gameRef.current) {
                        gameRef.current.off();
                    }
                };
            }, [gameId]);

            const saveGameState = (newState) => {
                if (gameRef.current) {
                    gameRef.current.put({ state: JSON.stringify(newState) });
                    
                    // Play sound on move
                    if (newState.turnCount > gameState?.turnCount) {
                        playSound('move');
                    }
                    
                    // Play win sound
                    if (newState.winner && !gameState?.winner) {
                        setTimeout(() => playSound('win'), 200);
                    }
                    
                    setGameState(newState);
                }
            };

            const createNewGame = () => {
                const newGameId = Math.random().toString(36).substring(2, 10).toUpperCase();
                const initialState = {
                    board: Array(16).fill(null),
                    turn: 'white',
                    turnCount: 0,
                    hands: {
                        white: { pawn: true, rook: true, knight: true, bishop: true },
                        black: { pawn: true, rook: true, knight: true, bishop: true }
                    },
                    pawnDirections: {},
                    winner: null,
                    players: { white: true, black: false }
                };
                
                setGameId(newGameId);
                setPlayerColor('white');
                
                // Save to localStorage
                localStorage.setItem('chessGameId', newGameId);
                localStorage.setItem('chessPlayerColor', 'white');
                
                const newGameRef = gunRef.current.get('chess-tictactoe').get(newGameId);
                
                // Put the data and wait for confirmation
                newGameRef.put({ state: JSON.stringify(initialState) }, (ack) => {
                    console.log('Game created and synced:', ack);
                });
                
                // Give Gun more time to sync across devices (1 second)
                setTimeout(() => {
                    setGameState(initialState);
                    setSetupMode('playing');
                }, 1000);
            };

            const joinGame = () => {
                if (!inputGameId) return;
                
                if (inputGameId.length < 6) {
                    alert('Game ID is too short. Please check and try again.');
                    return;
                }
                
                setJoining(true);
                setJoinAttempt(0);
                
                const joinGameRef = gunRef.current.get('chess-tictactoe').get(inputGameId.toUpperCase());
                
                // Increase attempts and wait time for cross-device sync
                let attempts = 0;
                const maxAttempts = 10;
                
                const tryJoin = () => {
                    setJoinAttempt(attempts + 1);
                    joinGameRef.once((data) => {
                        if (data && data.state) {
                            try {
                                const state = JSON.parse(data.state);
                                if (!state.players.black) {
                                    state.players.black = true;
                                    const gameIdUpper = inputGameId.toUpperCase();
                                    setGameId(gameIdUpper);
                                    setPlayerColor('black');
                                    
                                    // Save to localStorage
                                    localStorage.setItem('chessGameId', gameIdUpper);
                                    localStorage.setItem('chessPlayerColor', 'black');
                                    
                                    joinGameRef.put({ state: JSON.stringify(state) });
                                    setGameState(state);
                                    setSetupMode('playing');
                                    setJoining(false);
                                    setJoinAttempt(0);
                                } else {
                                    setJoining(false);
                                    setJoinAttempt(0);
                                    alert('This game already has 2 players. Please create a new game or try a different Game ID.');
                                }
                            } catch (e) {
                                setJoining(false);
                                setJoinAttempt(0);
                                alert('There was an error joining the game. Please try again or create a new game.');
                            }
                        } else {
                            // Retry if no data and haven't exceeded max attempts
                            attempts++;
                            if (attempts < maxAttempts) {
                                console.log(`Attempt ${attempts}/${maxAttempts} - waiting for game data...`);
                                setTimeout(tryJoin, 1000);
                            } else {
                                setJoining(false);
                                setJoinAttempt(0);
                                alert('Could not find the game. Make sure the Game ID is correct and the other player has created the game. If the problem persists, try creating a new game.');
                            }
                        }
                    });
                };
                
                tryJoin();
            };

            const isValidMove = (fromIndex, toIndex, piece, color) => {
                if (!gameState) return false;
                
                const fromRow = Math.floor(fromIndex / 4);
                const fromCol = fromIndex % 4;
                const toRow = Math.floor(toIndex / 4);
                const toCol = toIndex % 4;
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;

                if (gameState.board[toIndex] && gameState.board[toIndex].color === color) {
                    return false;
                }

                switch (piece) {
                    case 'pawn':
                        const direction = gameState.pawnDirections[fromIndex] || 1;
                        if (colDiff === 0 && rowDiff === direction && !gameState.board[toIndex]) {
                            return true;
                        }
                        if (Math.abs(colDiff) === 1 && rowDiff === direction && gameState.board[toIndex]) {
                            return true;
                        }
                        return false;

                    case 'rook':
                        if (rowDiff === 0 || colDiff === 0) {
                            return isPathClear(fromIndex, toIndex);
                        }
                        return false;

                    case 'knight':
                        return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                               (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

                    case 'bishop':
                        if (Math.abs(rowDiff) === Math.abs(colDiff)) {
                            return isPathClear(fromIndex, toIndex);
                        }
                        return false;

                    default:
                        return false;
                }
            };

            const isPathClear = (fromIndex, toIndex) => {
                const fromRow = Math.floor(fromIndex / 4);
                const fromCol = fromIndex % 4;
                const toRow = Math.floor(toIndex / 4);
                const toCol = toIndex % 4;

                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;

                while (currentRow !== toRow || currentCol !== toCol) {
                    const index = currentRow * 4 + currentCol;
                    if (gameState.board[index]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }

                return true;
            };

            const getValidMovesForPiece = (index) => {
                const moves = [];
                const piece = gameState.board[index];
                if (!piece) return moves;

                for (let i = 0; i < 16; i++) {
                    if (i !== index && isValidMove(index, i, piece.type, piece.color)) {
                        moves.push(i);
                    }
                }
                return moves;
            };

            const checkWinner = (board) => {
                const lines = [
                    [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15],
                    [0, 4, 8, 12], [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15],
                    [0, 5, 10, 15], [3, 6, 9, 12]
                ];

                for (const line of lines) {
                    const pieces = line.map(i => board[i]);
                    if (pieces.every(p => p && p.color === 'white')) return 'white';
                    if (pieces.every(p => p && p.color === 'black')) return 'black';
                }
                return null;
            };

            const handleSquareClick = (index) => {
                if (!gameState || gameState.winner || gameState.turn !== playerColor) return;

                if (selectedHandPiece && !gameState.board[index]) {
                    const newBoard = [...gameState.board];
                    newBoard[index] = { type: selectedHandPiece, color: playerColor };

                    const newHands = { ...gameState.hands };
                    newHands[playerColor][selectedHandPiece] = false;

                    const newPawnDirections = { ...gameState.pawnDirections };
                    if (selectedHandPiece === 'pawn') {
                        newPawnDirections[index] = playerColor === 'white' ? 1 : -1;
                    }

                    const newState = {
                        ...gameState,
                        board: newBoard,
                        hands: newHands,
                        pawnDirections: newPawnDirections,
                        turn: gameState.turn === 'white' ? 'black' : 'white',
                        turnCount: gameState.turnCount + 1,
                        winner: checkWinner(newBoard)
                    };

                    saveGameState(newState);
                    setSelectedHandPiece(null);
                    return;
                }

                if (selectedSquare !== null) {
                    if (validMoves.includes(index)) {
                        const newBoard = [...gameState.board];
                        const movingPiece = newBoard[selectedSquare];
                        
                        const capturedPiece = newBoard[index];
                        const newHands = { ...gameState.hands };
                        if (capturedPiece) {
                            newHands[capturedPiece.color][capturedPiece.type] = true;
                        }

                        newBoard[index] = movingPiece;
                        newBoard[selectedSquare] = null;

                        const newPawnDirections = { ...gameState.pawnDirections };
                        
                        if (movingPiece.type === 'pawn') {
                            const toRow = Math.floor(index / 4);
                            const direction = newPawnDirections[selectedSquare];
                            
                            if ((direction === 1 && toRow === 3) || (direction === -1 && toRow === 0)) {
                                newPawnDirections[index] = -direction;
                            } else {
                                newPawnDirections[index] = direction;
                            }
                            delete newPawnDirections[selectedSquare];
                        }

                        const newState = {
                            ...gameState,
                            board: newBoard,
                            hands: newHands,
                            pawnDirections: newPawnDirections,
                            turn: gameState.turn === 'white' ? 'black' : 'white',
                            turnCount: gameState.turnCount + 1,
                            winner: checkWinner(newBoard)
                        };

                        saveGameState(newState);
                        setSelectedSquare(null);
                        setValidMoves([]);
                    } else {
                        setSelectedSquare(null);
                        setValidMoves([]);
                    }
                } else if (gameState.board[index] && gameState.board[index].color === playerColor) {
                    const placedCount = gameState.board.filter(p => p && p.color === playerColor).length;
                    if (placedCount >= 3) {
                        setSelectedSquare(index);
                        setValidMoves(getValidMovesForPiece(index));
                        setSelectedHandPiece(null);
                    }
                }
            };

            const handleHandPieceClick = (pieceType) => {
                if (!gameState || gameState.winner || gameState.turn !== playerColor) return;
                if (!gameState.hands[playerColor][pieceType]) return;

                setSelectedHandPiece(selectedHandPiece === pieceType ? null : pieceType);
                setSelectedSquare(null);
                setValidMoves([]);
            };

            const resetGame = () => {
                if (!gameState) return;
                
                const initialState = {
                    board: Array(16).fill(null),
                    turn: 'white',
                    turnCount: 0,
                    hands: {
                        white: { pawn: true, rook: true, knight: true, bishop: true },
                        black: { pawn: true, rook: true, knight: true, bishop: true }
                    },
                    pawnDirections: {},
                    winner: null,
                    players: gameState.players
                };
                
                saveGameState(initialState);
                setSelectedSquare(null);
                setSelectedHandPiece(null);
                setValidMoves([]);
            };

            // Auto-deselect pieces when it's not your turn
            useEffect(() => {
                if (gameState && gameState.turn !== playerColor) {
                    setSelectedSquare(null);
                    setSelectedHandPiece(null);
                    setValidMoves([]);
                }
            }, [gameState?.turn]);

            const leaveGame = () => {
                if (confirm('Are you sure you want to leave this game?')) {
                    localStorage.removeItem('chessGameId');
                    localStorage.removeItem('chessPlayerColor');
                    setGameId('');
                    setPlayerColor(null);
                    setGameState(null);
                    setSetupMode('choose');
                    setSelectedSquare(null);
                    setSelectedHandPiece(null);
                    setValidMoves([]);
                }
            };

            if (setupMode === 'choose') {
                return (
                    <div className="game-container">
                        <h1 className="title">Chess Tic-Tac-Toe</h1>
                        <p className="subtitle">Online Multiplayer Edition</p>
                        {connected && (
                            <div className="connection-status">‚úì Connected to server</div>
                        )}
                        <div className="setup-screen">
                            <button className="primary-btn" onClick={createNewGame} style={{width: '100%', marginBottom: '10px'}}>
                                Create New Game
                            </button>
                            <div style={{margin: '20px 0', color: '#b58863'}}>or</div>
                            <input 
                                type="text" 
                                placeholder="Enter Game ID" 
                                value={inputGameId}
                                onChange={(e) => setInputGameId(e.target.value.toUpperCase())}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter' && inputGameId && !joining) {
                                        joinGame();
                                    }
                                }}
                                autoFocus
                                disabled={joining}
                            />
                            <button 
                                className="primary-btn" 
                                onClick={joinGame} 
                                style={{width: '100%'}}
                                disabled={!inputGameId || joining}
                            >
                                {joining ? `Joining... (${joinAttempt}/10)` : 'Join Game'}
                            </button>
                        </div>
                    </div>
                );
            }

            if (!gameState) {
                return (
                    <div className="game-container">
                        <div className="loading">
                            {gameId ? 'Reconnecting to game...' : 'Loading game...'}
                        </div>
                        {gameId && (
                            <div style={{textAlign: 'center', marginTop: '20px'}}>
                                <button className="secondary-btn" onClick={leaveGame}>
                                    Cancel
                                </button>
                            </div>
                        )}
                    </div>
                );
            }

            return (
                <div className="game-container">
                    <h1 className="title">Chess Tic-Tac-Toe</h1>
                    <p className="subtitle">Get four in a row to win!</p>
                    
                    <div className="game-id-display" style={{cursor: 'pointer'}} onClick={copyGameId}>
                        Game ID: <strong>{gameId}</strong>
                        <button 
                            style={{
                                marginLeft: '10px',
                                padding: '4px 12px',
                                fontSize: '12px',
                                background: copied ? '#90EE90' : '#f0d9b5',
                                color: '#2c1810',
                                border: '1px solid #8B4513',
                                borderRadius: '4px',
                                cursor: 'pointer'
                            }}
                            onClick={(e) => { e.stopPropagation(); copyGameId(); }}
                        >
                            {copied ? '‚úì Copied!' : 'üìã Copy'}
                        </button>
                        <div style={{fontSize: '12px', marginTop: '5px', color: '#b58863'}}>
                            Click to copy and share with your friend
                        </div>
                    </div>

                    {!gameState.players.black && playerColor === 'white' && (
                        <div className="waiting-message">
                            <div style={{fontSize: '18px', marginBottom: '8px'}}>‚è≥ Waiting for opponent...</div>
                            <div style={{fontSize: '12px', opacity: 0.8}}>
                                Share the Game ID above with your friend!
                            </div>
                        </div>
                    )}

                    {gameState.players.black && playerColor === 'white' && gameState.turnCount === 0 && (
                        <div style={{
                            textAlign: 'center',
                            padding: '12px',
                            background: '#90EE90',
                            borderRadius: '8px',
                            margin: '15px 0',
                            color: '#2c1810',
                            fontWeight: 'bold',
                            animation: 'celebration 0.5s ease-in-out'
                        }}>
                            ‚úì Opponent joined! Game starting...
                        </div>
                    )}

                    <div className="game-info">
                        {gameState.winner ? (
                            <div className="winner-message">
                                üéâ {gameState.winner === 'white' ? 'White' : 'Black'} Wins! üéâ
                            </div>
                        ) : (
                            <div className={`player-indicator ${gameState.turn === 'white' ? 'white-turn' : 'black-turn'}`}>
                                {gameState.turn === 'white' ? 'White' : 'Black'}'s Turn
                            </div>
                        )}
                    </div>

                    <div className="turn-info">
                        You are: <strong>{playerColor === 'white' ? '‚ö™ White' : '‚ö´ Black'}</strong>
                        {gameState.turn === playerColor && !gameState.winner && (
                            <div style={{marginTop: '5px', color: '#90EE90', fontWeight: 'bold'}}>
                                ‚ú® Your turn! ‚ú®
                            </div>
                        )}
                        {gameState.turn !== playerColor && !gameState.winner && (
                            <div style={{marginTop: '5px', color: '#b58863'}}>
                                ‚è≥ Waiting for opponent...
                            </div>
                        )}
                        {!gameState.winner && gameState.turnCount < 6 && gameState.turn === playerColor && (
                            <div style={{marginTop: '5px', fontSize: '12px'}}>
                                üìç Place a piece from your hand
                            </div>
                        )}
                        {!gameState.winner && gameState.turnCount >= 6 && gameState.turn === playerColor && (
                            <div style={{marginTop: '5px', fontSize: '12px'}}>
                                ‚ôüÔ∏è Place a piece or move an existing one
                            </div>
                        )}
                    </div>

                    <div className="player-hands">
                        <div className="hand-label">Your Hand</div>
                        <div className="hand">
                            {Object.entries(gameState.hands[playerColor]).map(([type, available]) => (
                                <div
                                    key={type}
                                    className={`hand-piece ${selectedHandPiece === type ? 'selected' : ''} ${!available ? 'captured' : ''}`}
                                    onClick={() => handleHandPieceClick(type)}
                                    style={{cursor: available && gameState.turn === playerColor ? 'pointer' : 'not-allowed'}}
                                >
                                    {PIECES[playerColor][type]}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="board">
                        {gameState.board.map((piece, index) => (
                            <div
                                key={index}
                                className={`square ${selectedSquare === index ? 'selected' : ''} ${validMoves.includes(index) ? 'valid-move' : ''}`}
                                onClick={() => handleSquareClick(index)}
                            >
                                {piece && (
                                    <div className="piece">
                                        {PIECES[piece.color][piece.type]}
                                        {piece.type === 'pawn' && (
                                            <span className="pawn-direction">
                                                {gameState.pawnDirections[index] === 1 ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è'}
                                            </span>
                                        )}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>

                    <div className="controls">
                        {gameState.winner && (
                            <button className="primary-btn" onClick={resetGame}>
                                Play Again
                            </button>
                        )}
                        <button 
                            className="secondary-btn" 
                            onClick={() => setSoundEnabled(!soundEnabled)}
                            title={soundEnabled ? 'Mute sounds' : 'Enable sounds'}
                        >
                            {soundEnabled ? 'üîä' : 'üîá'}
                        </button>
                        <button className="secondary-btn" onClick={leaveGame}>
                            Leave
                        </button>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
